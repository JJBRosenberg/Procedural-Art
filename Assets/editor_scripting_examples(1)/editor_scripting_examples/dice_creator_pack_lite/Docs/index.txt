/**
* @file DieAreaFinder.cs

 * The DieAreaFinder class is a helper script used internally by the DieSidesEditor class to process 
 * all triangles in a model to deduct how many sides a model has and what the normals of those sides are.
 * 
 * The basic principle of the script is this:
 * - first create DieArea instances for each triangle of the first submesh of a given Mesh 
 * in order to register some data about those triangles (area, normal, centerpoint)
 * - then combine all DieAreas that share the same normal, adding their areas, averaging the new center points.
 *	 (note that this assumes that areas with similar normals are also adjacent, 
 *	 which will be true for dice models, but not for other models eg)
 * - lastly filter out all areas whose area size is less than some cutoff value * the max area size encountered,
 * so that we are left with only the sides that actually represent sides of a die.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
	* @changes 1.1 - added an area count to the DieArea class to make sure we can calculate the correctly weighted average of the different die areas
 */

/**
* @file DieSide.cs

 * The DieSide class represents all there is to know about a single DieSide:
 * - the normal of the side
 * - the centerpoint of the side
 * - an array of ints describing the data values stored for this side
 * 
 * We use an array of ints as values since it is the most general approach:
 * - you can use an int to represent a side ID or a single die value
 * - you can use multiple ints to represent multiple values for example for Descent dice
 * - you can match ints to their string counterpart using lookup dictionaries
 *	 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieSideMatchInfo.cs

 * DieSideMatchInfo is returned by the DieSides component, describing which DieSide most
 * closely matches the current state of the transform the DieSides component is attached to.
 * For example if you have a D6 and the side with a 3 on it is pointing upwards, then
 * getting the DieSideMatchInfo for the DieSides component attached to that D6 will return
 * the DieSide representing the values for the side with the 3 on it (assuming you entered
 * all DieSide data correctly ofcourse).
 * "Exact" means that the side is pointing exactly upward so there can be no discussion 
 * about the outcome of the roll.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieSides.cs

 * DieSides stores a collection of DieSide instances and can tell which DieSide is currently
 * the closest match (based on side normals and transform rotation) and whether that match is exact.
 * Exact refers to the state where there can be no discussion about the result of the die.
 * 
 * The DieSide instances themselves are generated by the DieSidesEditor, based on information
 * gathered through the DieAreaFinder.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file ARollable.cs

 * ARollable is the abstract base class for anything rollable, eg Die or DieCollection.
 * 
 * It provides:
 * - an event mechanism allowing you to listen for RollBegin and RollEnd events and code to trigger these events
 * - an interface to determine whether a Rollable is still rolling
 * - an interface to start a roll
 * - an interface to retrieve the result of a roll. 
 * 
 * Note that although it is possible to retrieve the result of a die at any time, retrieving it only 
 * AFTER the OnRollEnd event will be much cheaper, because the result is static from that point onward 
 * (until the next OnRollBegin) and therefore also cached.
 * 
 * It has two methods you need to override while subclassing: Roll and createRollResult.
 * See the Die and DieCollection classes for examples.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file Die.cs

 * This Die class subclasses ARollable to provide an abstract base for a single Die.
 * The only thing this adds to the ARollable class is that we wrap a DieSides component
 * and pass it to an instance of DieResult everytime the roll result is requested.
 * 
 * In itself the Die class still doesn't do anything, you have to subclass it to actually 
 * roll the die and determine when the roll is done, either using Physics or some sort of 
 * manual roll. Only a PhysicsExample has been provided at the moment, see PhysicsDie.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieDebugEventListener.cs

 * Simple debug class that prints information about status and the events thrown by a Die.
 * Only usuable during development.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieDebugUI.cs

 * Shows debug information for a Die on a small worldcanvas.
 *
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieResult.cs

 * Represents the result for a single Die roll.
 * For more info see IRollResult.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file IRollResult.cs

 * A generic interface for roll results, no matter whether you are rolling a single 
 * die or a collection of dice.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file MouseClickDieRoller.cs

 * An example of how we could trigger the rolling of a die by using a mouse.
 * It depends on the Die having an actual collider to raycast against.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file NullResult.cs

	 * Represents a zero result, used for disabled dice, to avoid exceptions.
	 * 
	 * @author J.C. Wichman
	 * @copyright Inner Drive Studios
	 */

/**
* @file RightClickCameraDieZoomer.cs

 * Sample script to demonstrate how we can zoom in on the result of a single Die.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file PhysicsDie.cs

 * This Die subclass allows you to physically throw a Die.
 * 
 * Throwing is implemented by simply setting a velocity and an angularVelocity based on 
 * the parameters you specify.
 * Once the rigidbody attached to the same GameObject falls asleep, the roll is consider to
 * be done (in the general case, see other options below).
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file PhysicsDieAvoider.cs

 * This is a utility script to use in combination with a PhysicsDieController,
 * to make sure dice avoid each other and any other GameObject that has this component,
 * it has no use on its own.
 * 
 * Dice leaning into eachother or Dice leaning into a wall may cause a Die value
 * to not be exact, it may be like almost in between two values for example.
 * To avoid this you can attach a PhysicsDieAvoider to any objects you want the dice
 * to avoid, this includes both dice and environment walls for example
 * (but not the floor or the dice will be "bouncin'-all-day" !).
 * 
 * Upon collision an explosion force will be added to the objects that actually have a 
 * non kinematic rigidbody (so although you can attach this to a wall, the wall itself
 * will not be blown away for example). This causes dice to roll away from eachother or
 * from the wall, and reduces the chance of getting these aforementioned non exact values.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieCollection.cs

 * DieCollection is a component to which you can add other ARollable instances,
 * allowing you to track events and results for a group. Examples of ARollable instances
 * are of course Die, PhysicsDie but also DieCollection itself, in other words you can also
 * track multiple collections using a collection.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieCollectionDebugEventListener.cs

 * A debug class that can be used to print info about what a DieCollection is doing.
 * You can also use the DieCollectionDebugUI instead.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieCollectionDebugUI.cs

 * Implements a DieCollectionDebugUI for a maximum of 9 dice, to show some information
 * about the state of those dice (rollables to be more precise), their current value, 
 * etc. It also sums up the total over the whole collection.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieCollectionResult.cs

 * DieCollectionResult represents the totals and status for a whole collection of dice 
 * (rollables to be more exact), adding the results of all items in the collection together.
 * Of course you can still inspect the individual results by inspecting the individual items
 * in the collection.
 * 
 * The DieCollectionResult for a die with 1 value per side and a die with 3 values per side,
 * will also contains 3 values per side. On other words, a DieCollectionResult will make most
 * sense when applied to similar dice.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file KeyPressCollectionRoller.cs

 * A class that allows you to trigger the main methods on a DieCollection through key presses.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DiceCreatorLogoRenderer.cs

 * Helper class to show a small DieCreator / IDS Logo.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieSidesEditor.cs

 * The DieSidesEditor provides the editor for the DieSides component, which allows you to fill
 * the DieSides component with all the required DieSides instances based on data provided by the
 * DieAreaFinder class. This allows you to construct your own die with custom side data for each side, 
 * with handy features such as viewing the side normals, rotating the transform to match a certain
 * value, and highlighting a specific DieSide.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios 2018
 */

/**
* @file MaterialSetRebuilder.cs

 * MaterialSetRebuilder is a utility script to rebuild all MaterialSets including the final MaterialSetCollection
 * from all material folders in the Dice Creator Package. 
 * 
 * Base functionality:
 * - delete all existing materialsets from PathConstants.MATERIALS_FOLDER (by default Assets/InnerDriveStudios/DiceCreator/Materials)
 * - go through all folders in PathConstants.MATERIALS_FOLDER WITHOUT a _ in front of their name,
 *		- go through all materials found in each folder and:
 *			- rename the material to its basename + its parent material folder name
 *			 eg BlackGloss/???_Whatever.mat becomes BlackGloss/???_BlackGlossMaterial.mat
 *		- create a MaterialSet instance corresponding to the name of found folder and 
 *		 add all materials within that folder to the MaterialSet
 * - Lookup or create (if non existent) _MaterialsetCollection and fill it all created MaterialSet's
 * 
 * After rebuilding all material set they can be tested by running the default 001_gettingstarted scene
 * (all material sets should show up in the dropdownbox of the material manager).
 * 
 * Usage scenario (also see manual):
 *	- Select the PlasticPurple material folder, duplicate it and rename it to PlasticGreen
 *	- Run the MaterialSetRebuilder through the IDS menu option to:
 *		- rename all materials in the PlasticGreen to D2_PlasticGreenMaterial etc
 *		- create a MaterialSet called PlasticGreen
 *	- Now you can adjust all values for the PlasticGreenMaterials and quickly assign them to the dice
 *	
 *	Known issues:
 *	- for some reason the process triggers a 'was already deleted' exception for no apparent reason.
 *	Workaround:
 *	- just run the script again
 */

/**
* @file PathConstants.cs

 * Some paths referenced in this asset, all located in one place.
 * If you move any assets, please make sure the paths in this class are still valid.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file PhysicsDieEditor.cs

 * Simple editor that checks whether the component that the PhysicsDie is attached to
 * has a physics material set, and if not, sets the default DiePhysicsMaterial.physicMaterial
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file SideUtility.cs

	* SideUtility is a simple editor window that allows you to attach a specific prefab to each and every side of a die.
	* If the prefab has a component that implements IDieSideAware it will also pass the DieSide info to that component on the
	* instantiated prefab.
	* 
	* @author J.C. Wichman / Inner Drive Studios
	*/

/**
* @file MaterialManagerUI.cs

 * UI that lets you change the material for the given DieCollection to the material from a selected materialset.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file MaterialSet.cs

 * Describes a set of materials.
 * 
 * Can be used either at editor or at runtime to assign materials to gameobjects quickly by using 
 * specific naming conventions (see the MaterialSetUtility).
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file MaterialSetCollection.cs

 * Combines a bunch of MaterialSets into a collection that we can use to switch materials
 * at editor or runtime.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file MaterialSetUtility.cs

 * Utility class to match GameObjects with materials from a given MaterialSet.
 * Matching is done based on part of the name of a given GameObject. 
 * 
 * The principle is simple:
 * - giving a material, we map its name to a key
 * - giving a gameobject, we map the name to a key as well
 * - if the keys of material and gameobject match we assign the material to the gameobject
 * 
 * To avoid this becoming a O(mn) operation, we first build up a quick dictionary of
 * the material name keys mapped to their respective materials. The reason we do that here
 * instead of in the MaterialSet is that we have no control over when to dirty that dictionary cache.
 * 
 * Current key generation: 
 * take everything in the given name up to the last _ in the name, 
 * if no _ is found the whole string is used.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file DieSideAwareSpritePrefab.cs

 * Example implementation of IDieSideAware to handle attached sprites to a prefab.
 * This assumes the prefab has an array of Sprite matching with DieSide values and a SpriteRenderer to assign them to.
 * 
 * @author J.C. Wichman 
 * @copyright Inner Drive Studios 2019
 */

/**
* @file DieSideAwareTextDie.cs

 * Example implementation of IDieSideAware to handle textfields attached to a prefab.
 * Basically just passes on the values of a DieSide as a string to the text of the TextMesh.
 * 
 * @author J.C. Wichman 
 * @copyright Inner Drive Studios 2019
 */

/**
* @file IDieSideAware.cs

	 * Describes an interface for instances of prefabs that have been attached to a Die through 
	 * the DieSideUtility (which is an addon utility instead of using materials to represent die faces).
	 * IF such an instance implements this interface, it receives information about its index and 
	 * the DieSide info it represents.
	 * 
	 * @author J.C. Wichman 
 * @copyright Inner Drive Studios 2019
	 */

/**
* @file ActivationUtility.cs

 * A simple utility class to toggle gameobjects on/off based on key presses for the demo scene.
 *
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file GroundUtility.cs

	 * Utility class to floor an item.
	 * 
	 * @author J.C. Wichman
	 * @copyright Inner Drive Studios
	 */

/**
* @file RollableAudio.cs

 * Scaffold for an audio script that you can add to any rollable.
 * It is unfinished, but provides a starting point.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

/**
* @file StringUtility.cs

 * Simple string utility to concatenate IEnumerable<int>'s (eg List<int>, int []) 
 * to a comma separated string.
 * 
 * @author J.C. Wichman
 * @copyright Inner Drive Studios
 */

